/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict-local
 * @format
 */

'use strict';

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 */
import {CacheOptions} from '@wora/cache-persist';

declare module '@wora/offline-first' {
  declare type Request<T> = {
    payload: T,
    backup?: any,
    sink?: any,
    ...
  };
  declare export type OfflineRecordCache<T> = {
    id: string,
    request: Request<T>,
    fetchTime: number,
    retry?: number,
    error?: any,
    serial?: boolean,
    ...
  };
  declare type OfflineFirstOptions<T> = {
    manualExecution?: boolean,
    execute: (offlineRecord: OfflineRecordCache<T>) => Promise<any>,
    start?: (
      mutations: Array<OfflineRecordCache<T>>,
    ) => Promise<Array<OfflineRecordCache<T>>>,
    onExecute?: (
      mutation: OfflineRecordCache<T>,
    ) => Promise<OfflineRecordCache<T>>,
    finish?: (
      mutations: $ReadOnlyArray<OfflineRecordCache<T>>,
      error?: Error,
    ) => Promise<void>,
    onComplete?: (options: {
      offlineRecord: OfflineRecordCache<T>,
      response: any,
      ...
    }) => Promise<boolean>,
    onDiscard?: (options: {
      offlineRecord: OfflineRecordCache<T>,
      error: any,
      ...
    }) => Promise<boolean>,
    onPublish?: (
      offlineRecord: OfflineRecordCache<T>,
    ) => Promise<OfflineRecordCache<T>>,
    compare?: (v1: OfflineRecordCache<T>, v2: OfflineRecordCache<T>) => number,
    ...
  };
  declare export class OfflineFirst<T> {
    constructor(persistOptions?: CacheOptions): this;
    setOfflineOptions(offlineOptions?: OfflineFirstOptions<T>): void;
    purge(): Promise<boolean>;
    isManualExecution(): boolean;
    hydrate(): Promise<boolean>;
    isOnline(): boolean;
    subscribe(callback: (state: any, action: any) => void): () => void;
    notify(): void;
    getState(): {
      [key: string]: any,
      ...,
    };
    remove(id: string): Promise<void>;
    set(id: string, value: OfflineRecordCache<T>): Promise<void>;
    getListMutation(): Array<OfflineRecordCache<T>>;
    process(): Promise<void>;
    executeMutation(offlineRecord: OfflineRecordCache<T>): Promise<void>;
    publish(options: {
      id?: string,
      request: Request<T>,
      serial?: boolean,
      ...
    }): Promise<OfflineRecordCache<T>>;
  }
}
